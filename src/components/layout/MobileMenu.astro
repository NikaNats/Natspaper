---
import IconX from "@/assets/icons/IconX.svg";
import IconMenuDeep from "@/assets/icons/IconMenuDeep.svg";
import NavMenu from "./NavMenu.astro";
import { getI18n, type Lang } from "@/i18n";

const { currentPath, locale, otherLanguageLinks } = Astro.props;
const { t } = getI18n(locale as Lang);
---

<!-- 
  Mobile Menu Breakpoint Configuration
  ====================================
  The menu switches from hamburger to desktop at the 'md' breakpoint (768px).
  To change this, update all 'md:' prefixes below to your preferred breakpoint.
  Available options: sm (640px), md (768px), lg (1024px)
-->
<mobile-menu>
  <!-- Toggle Button - Hidden on md+ screens -->
  <button
    id="menu-btn"
    class="relative z-50 min-h-11 min-w-11 rounded-md p-2 text-foreground transition-colors hover:bg-muted hover:text-accent focus:outline-none md:hidden"
    aria-label={t("nav.openMenu")}
    aria-expanded="false"
    aria-controls="mobile-menu-overlay"
  >
    <IconMenuDeep class="size-7" aria-hidden="true" />
  </button>

  <!-- 
    Overlay / Menu Container 
    - Using data-state="closed|open" for reliable styling
    - visibility:hidden ensures it cannot block clicks when closed
    - Breakpoint: md (768px) - hamburger below, desktop menu above
  -->
  <div
    id="mobile-menu-overlay"
    data-state="closed"
    class="fixed inset-0 z-100 flex flex-col items-center justify-center bg-background/95 p-4 backdrop-blur-sm transition-all duration-300 md:static md:z-auto md:flex-row md:bg-transparent md:p-0 md:backdrop-blur-none"
    role="dialog"
    aria-modal="true"
    aria-label={t("nav.mainMenu")}
  >
    <!-- Close Button (Inside Overlay) - Hidden on md+ screens -->
    <button
      id="menu-close-btn"
      class="absolute top-6 right-6 min-h-11 min-w-11 rounded-md p-2 text-foreground transition-colors hover:bg-muted hover:text-accent focus:outline-none md:hidden"
      aria-label={t("nav.closeMenu")}
    >
      <IconX class="size-8" aria-hidden="true" />
    </button>

    <!-- Content -->
    <div class="flex flex-col items-center gap-8 md:flex-row md:gap-4">
      <NavMenu
        currentPath={currentPath}
        locale={locale}
        otherLanguageLinks={otherLanguageLinks}
      />
    </div>
  </div>
</mobile-menu>

<style>
  /* Mobile Styles (Default) */
  #mobile-menu-overlay[data-state="closed"] {
    opacity: 0;
    visibility: hidden;
    pointer-events: none;
    transform: translateY(10px);
  }

  #mobile-menu-overlay[data-state="open"] {
    opacity: 1;
    visibility: visible;
    pointer-events: auto;
    transform: translateY(0);
  }

  /**
   * Desktop Reset (Override mobile styles)
   * Breakpoint: 768px (md) - configurable by changing this value
   * Available options: 640px (sm), 768px (md), 1024px (lg)
   */
  @media (min-width: 768px) {
    #mobile-menu-overlay[data-state] {
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
      transform: none;
      position: static;
      display: flex;
    }
  }
</style>

<script>
  // Define custom element to encapsulate logic naturally
  class MobileMenu extends HTMLElement {
    constructor() {
      super();
      // Wait for children to be parsed
      this.init();
    }

    init() {
      const openBtn = this.querySelector(
        "#menu-btn"
      ) as HTMLButtonElement | null;
      const closeBtn = this.querySelector(
        "#menu-close-btn"
      ) as HTMLButtonElement | null;
      const overlay = this.querySelector(
        "#mobile-menu-overlay"
      ) as HTMLElement | null;
      const links = this.querySelectorAll("a");

      if (!openBtn || !closeBtn || !overlay) return;

      // WCAG 2.1.2: Get all focusable elements for focus trapping
      const getFocusableElements = (): HTMLElement[] => {
        const focusable = overlay.querySelectorAll<HTMLElement>(
          'a[href], button:not([disabled]), input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])'
        );
        return Array.from(focusable);
      };

      // WCAG 2.1.2: Trap focus within the menu when open
      const handleTabKey = (e: KeyboardEvent) => {
        if (e.key !== "Tab" || overlay.getAttribute("data-state") !== "open")
          return;

        const focusableElements = getFocusableElements();
        if (focusableElements.length === 0) return;

        const firstElement = focusableElements[0];
        const lastElement = focusableElements[focusableElements.length - 1];

        // Guard against undefined (should not happen but TypeScript requires it)
        if (!firstElement || !lastElement) return;

        if (e.shiftKey) {
          // Shift+Tab: if on first element, go to last
          if (document.activeElement === firstElement) {
            e.preventDefault();
            lastElement.focus();
          }
        } else {
          // Tab: if on last element, go to first
          if (document.activeElement === lastElement) {
            e.preventDefault();
            firstElement.focus();
          }
        }
      };

      const toggleMenu = (isOpen: boolean) => {
        const state = isOpen ? "open" : "closed";
        overlay.setAttribute("data-state", state);
        openBtn.setAttribute("aria-expanded", isOpen.toString());

        // Lock body scroll prevents background scrolling
        if (isOpen) {
          document.body.style.overflow = "hidden";
          // WCAG 2.4.3: Move focus to close button when menu opens
          requestAnimationFrame(() => closeBtn.focus());
        } else {
          document.body.style.overflow = "";
          // Return focus to open button, but only if the element is still
          // connected (guard against page crash during View Transitions navigation)
          requestAnimationFrame(() => {
            if (openBtn.isConnected) {
              openBtn.focus();
            }
          });
        }
      };

      // Event Listeners
      openBtn.addEventListener("click", e => {
        e.stopPropagation();
        toggleMenu(true);
      });

      closeBtn.addEventListener("click", e => {
        e.stopPropagation();
        toggleMenu(false);
      });

      // Close when clicking any link (SPA navigation).
      // Skip the requestAnimationFrame focus-return to prevent a crash when
      // Chromium fires the RAF callback against a detached element during the
      // Astro View Transitions DOM swap.
      links.forEach(link => {
        link.addEventListener("click", () => {
          overlay.setAttribute("data-state", "closed");
          openBtn.setAttribute("aria-expanded", "false");
          document.body.style.overflow = "";
        });
      });

      // Close on Escape key
      document.addEventListener("keydown", e => {
        if (
          e.key === "Escape" &&
          overlay.getAttribute("data-state") === "open"
        ) {
          toggleMenu(false);
        }
      });

      // WCAG 2.1.2: Add focus trap listener
      document.addEventListener("keydown", handleTabKey);
    }
  }

  // Register the component immediately
  // Checking strictly if it's already defined avoids HMR errors in dev
  if (!customElements.get("mobile-menu")) {
    customElements.define("mobile-menu", MobileMenu);
  }

  // Astro View Transitions: after each SPA navigation, ensure the menu is
  // reset to closed.  The ClientRouter DOM morph can leave data-state=""
  // on the #mobile-menu-overlay element.  This handler is registered once
  // at module-scope (not inside the class) to avoid duplicating listeners
  // across navigations.
  document.addEventListener("astro:after-swap", () => {
    const overlay = document.querySelector(
      "#mobile-menu-overlay"
    ) as HTMLElement | null;
    const btn = document.querySelector("#menu-btn") as HTMLButtonElement | null;
    if (overlay) {
      overlay.setAttribute("data-state", "closed");
    }
    if (btn) {
      btn.setAttribute("aria-expanded", "false");
    }
    document.body.style.overflow = "";
  });
</script>

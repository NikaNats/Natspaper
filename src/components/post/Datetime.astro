---
import dayjs from "dayjs";
import utc from "dayjs/plugin/utc";
import timezone from "dayjs/plugin/timezone";
import IconCalendar from "@/assets/icons/IconCalendar.svg";
import { SITE } from "@/config";

// These extensions are fine to run at the module level
dayjs.extend(utc);
dayjs.extend(timezone);

export interface Props {
  class?: string;
  size?: "sm" | "lg";
  timezone?: string;
  pubDatetime: string | Date;
  modDatetime?: string | Date | null;
}

const {
  pubDatetime,
  modDatetime,
  size = "sm",
  class: className = "",
  timezone: postTimezone,
} = Astro.props;

// REFACTORED: Use dayjs's own `isAfter` method. It's more readable and idiomatic.
const isModified =
  modDatetime && dayjs(modDatetime).isAfter(dayjs(pubDatetime));

// REFACTORED: Separate the logic for selecting the date from formatting it.
const dateToShow = isModified ? modDatetime : pubDatetime;
const effectiveTimezone = postTimezone ?? SITE.timezone;

const datetime = dayjs(dateToShow).tz(effectiveTimezone);
const formattedDate = datetime.format("D MMM, YYYY");
---

<div
  class:list={["flex items-center gap-2", "metadata", className]}
  data-testid="post-datetime"
>
  <IconCalendar
    class:list={["inline-block size-5 min-w-5", { "scale-90": size === "sm" }]}
  />

  {
    /* REFACTORED: Apply sizing classes to a single parent span to avoid repetition (DRY principle). */
  }
  <span class:list={["text-sm", { "sm:text-base": size === "lg" }]}>
    {isModified && "Updated: "}
    <time datetime={datetime.toISOString()}>{formattedDate}</time>
  </span>
</div>
